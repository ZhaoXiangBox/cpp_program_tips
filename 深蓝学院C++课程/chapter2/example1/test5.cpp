#include<iostream>

/********** 类型详述——变量及其类型*********************
变量：对应一段内存空间，可以改变其中的内容；
初始化：在构造变量之初为其赋予初始值；
缺省初始化：
    函数内部定义一个变量，但是没有给其初始化，那么会耗费CPU去给其赋予一个任意随机值。
    函数外部定义一个全局变量，尽管没有给其赋予初始值，那么系统也会给其赋予 0 。

直接/拷贝初始化：

其他初始化：
    赋值的时候需要注意类型的转换 ，小心精度的丢失。
        浮点数和整数之间的转换；
        布尔值： 
            bool :该类型的变量只会有两种值【0，1】，所以无论给其复制啥，都无法改变其值的范围，要么0 要么1
    隐式类型转换不只发生在赋值的时候：
        if()
        while()
        数值比较:
            无符号数据与有符号数据之间的比较  ****
            

***************************************************/

extern int g_x;

// 此种写法错误，因为 后面的 “=6” 是一个初始化，
//编译器会认为该语句是一个初始化，导致出现重定义问题。
// extern int q_x = 6; 

int y ;    // 全局变量，但无初始化，默认就是0 .

int main()
{
    std::cout<<g_x<<std::endl;

    int x ; // 缺省初始化，在函数内部，其内存中的值为任意值。
    std::cout<<"X: "<<x << " y: "<<y<<std::endl;

    int y(10); // 直接初始化；
    int z = 10 ; // 拷贝初始化；
    int p{10};   // 直接初始化； 

    std::cout<< "y: "<<y<<" z: "<<z<<" p: "<<p<<std::endl;

    int m = 1.4 ;
    std::cout<<"m: "<<m<<std::endl;

    int o = -1;
    unsigned int uo = 3;
    // C++ 会将 int o 转换为 uint，所以 -1 转换为 uint 之后，这个值非常大，远远大于 uo=3 ,所以结果为 false .
    // 因此，尽量只比较同类的变量。但是，在C++20 中引入了一些函数（std::cmp_XXX），用来显示解决 不同数据类型之间的 比较 。
    std::cout<<"o > uo bool: "<<( o < uo )<<std::endl;   // 但是输出为 0，bool 为false

    return 0;
    
}