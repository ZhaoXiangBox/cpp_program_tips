#include<iostream>

/*************** 复合类型：从指针到引用  **********************
 *
 * 指针的引入，主要是为了增加程序的执行效率；间接引用替代了变量之间的拷贝操作 .磁盘的读写成本比较高，会降低程序的执行效率 .
 * 指针还可以在函数中对其进行传值操作 ；
 * 
 * 指针的问题：
 *  可以为空
 *  可能误操作；
 * 
 * 引用：
 *  引用是对象的别名；不能绑定字面值。
 *  构造的时候，绑定对象，一旦绑定之后，在其生命周期以内，就不能更换绑定对象；
 *  操作引用比操作指针安全，其实引用也是通过指针实现的。
 * 
 * 指针的引用：
 *  指针是对象，因此可以定义该指针的引用,在解析的时候按照： 从右向左的顺序；
 *  int * p = &val;
 *  int* &ptr = p;   // 该指针类型的 引用 ptr 将代替 指针变量 *p .
 * 
 * 没有引用的引用：如：int& &ptr = .... ; (错误 ！！！)
 * 
 * *******************************************************/

struct Str{
    int x;
    float y;
    double z;
};

Str *ptr ;  // 结构体制指针的大小是固定的 ，不会因为内部变量的增多，其本身的指针的大小变大 。


// 指针可以修改函数 形参 所传入的地址中存储的值 
void add_1(int *p)
{
    *p = *p + 1 ;
    return;
}


void fun(int &param)
{
    param = param + 1 ;
    return ;
}


int main()
{
    int x = 30 ;
    int y = 20 ;

    int *p = &x;
    std::cout<<" *p: "<<*p<<" p: "<<p<<std::endl;

    p=&y;
    std::cout<<" *p: "<<*p<<" p: "<<p<<std::endl;

    add_1(&x);
    std::cout<< x <<std::endl;

    add_1(p);
    std::cout<< *p <<std::endl;

    /***********************************************/
    int m = 0 ;
    int &ref = m; // 从此以后，引用 ref 就将代表 m ,操作ref就是操作 m，引用 ref 就是 变量 m 的别名 。

    // 引用变量只能在初始化的时候绑定一个 变量，仅此一种可能。因此，不容易出现空引用的时候，造成错误。
    // int n =0;
    // &ref = n;

    std::cout<<" m: "<<m<<std::endl;
    fun(m);    // 将 m 传递给 引用形参，因此函数的形参就是该函数的别名，因此可以操作该变量所指向内存的值。
    std::cout<< " m: "<<m<<std::endl;

    return 0;
}