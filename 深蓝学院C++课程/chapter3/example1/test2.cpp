#include<iostream>
#include<limits>


/********** 数组的引入：  *********************
数组的复杂声明：
    - 指针数组与数组的指针
    - 声明数组的引用

数组中的元素访问
    - 数组对象是一个左值
    - 使用时通常会转换成相应的指针类型
    - x[y]  --> *((x) + (y))

数组到指针的隐式转换：
    - 使用数组对象时，通常情况下会产生数组到指针的隐式转换
    - 隐式转换会丢失一部分信息
    - 可以通过声明引用来避免隐式转换

注意：不要使用 extern 来声明数组，但是可以使用 extern 来从外部得到变量的值。


通过数组的指针，可以获得数组开头或者结尾的指针：    
    int a[3];
    a+3 --> 表示数组结尾的指针 std:cend(a)
    a --> 表示数组的开头的指针 std::cbegin(a) 

指针的算数：
    增加 、减少 、比较（仅仅限于两个指针值相同一个数组） 、求距离 、 解引用 、 指针索引 、

***************************************************/

extern int array_a[] ; // 正确的外部数组的写法 
void fun();

int main()
{
    // 指针的数组
    int x1 ;
    int x2 ;
    int x3 ;
    int* a[3]={&x1,&x2,&x3};

    // 数组的指针
    int y[3]={1,2,3};
    int (*aa)[3] = &y ;

    // 数组的引用，c 是 b 的别名
    int b[3];   // 数组中的元素标号是从 0 开始的
    int (&c)[3] = b ;

    int d_array[3] = {1,2,3};  // 数组名代表的是数组的首地址 d_array , 
    
    auto e = b ; // 这样隐式转换之后，将丢失一部分信息，比如 e 就丢失了数字的大小 。
    std::cout<<"auto e size: "<<sizeof(e) / sizeof(int) <<std::endl;

    // 通过对比可以发现 该方式所传递的数组地址是一致的，切忌此处不能 使用 extern int *array ，该种使用方式是错误的，不能隐式的把地址传递过来
    fun();
    std::cout<<"extern array_a address : "<<array_a<<std::endl;

    return 0;    
}